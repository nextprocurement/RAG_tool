import pathlib
import argparse
import os
import time
import yaml
import dspy
from src.utils.utils import *
from dotenv import load_dotenv
from src.utils.utils import init_logger
from src.utils.vector_store_utils import Chunker
from dspy.primitives.assertions import assert_transform_module, backtrack_handler
import functools
from src.acronyms_dspy.acronym_expander import HermesAcronymExpander, AcronymExpanderModule
from src.acronyms_dspy.acronym_detector import HermesAcronymDetector, AcronymDetectorModule


def load_config(config_path):
    """
    Load configuration from YAML.
    """
    with open(config_path, 'r') as file:
        config = yaml.safe_load(file)
    return config

if __name__ == "__main__":
    
    config_path = pathlib.Path("config/settings.yaml")
    config = load_config(config_path)
    
    # Initialize logger
    logger = init_logger(config['logger'])
    logger.info("Cargando la configuración desde YAML...")
    
    logger.info("Cargando las variables de entorno desde el archivo .env...")
    path_env = pathlib.Path(
            "/export/usuarios_ml4ds/cggamella/RAG_tool/.env")
    load_dotenv(path_env)
    
    parser = argparse.ArgumentParser(description="Acronym Detection and Expansion Tool")
    parser.add_argument("--llm_type", type=str, default="llama",
                        help="Type of large language model to use")
    parser.add_argument("--data_path", type=str,
                        help="Path to data file",
                        default='/export/usuarios_ml4ds/cggamella/RAG_tool/files/acronyms_paper.xlsx')
    parser.add_argument("--action", type=str, choices=["detect", "expand", "both"], default="both",
                        help="Action to perform: detect acronyms, expand acronyms, or both")
    parser.add_argument("--do_train", action='store_true',
                        help="Indicate if the models should be trained.")
    parser.add_argument("--context_window", type=int, default=3000,  
                        help="Size of the context window for the chunker")
    parser.add_argument("--max_windows", type=int, default=100,
                        help="Maximum number of windows the chunker can generate")
    parser.add_argument("--window_overlap", type=float, default=0.1,
                        help="Percentage of overlap between windows generated by the chunker")

    args = parser.parse_args()

    # Initialize the model based on the specified type
    if args.llm_type == "llama":
        logger.info("Inicializando el modelo LLaMA...")
        lm = dspy.HFClientTGI(model="meta-llama/meta-llama-3-8b", port=8090, url="http://127.0.0.0")
    elif args.llm_type == "gpt":
        logger.info("Inicializando el modelo GPT...")
        # Load OpenAI env from file .env
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY is not set in the environment.")
        os.environ["OPENAI_API_KEY"] = api_key

        lm = dspy.OpenAI(model="gpt-3.5-turbo")
    else:
        raise ValueError(f"Invalid LLM type: {args.llm_type}")
    
    # Configure dspy with model and temperature selected
    dspy.settings.configure(lm=lm, temperature=0)
    # It seems to be mandatory to configure the settings of dspy backtracking before using it
    # Configuration of dspy backtracking
    dspy.settings.configure(trace=[])
    
    #@TODO: Create file folder where all excel files will be stored instead of single file.
    
    # Decide whether to train based on configuration file and arguments
    do_train = getattr(args, 'do_train', False) or config.get('train_all_modules', False)
    # Get the column name from the configuration
    column_name = config.get('data_column_name', 'text')
    
    if args.action in ["detect", "both"]:
        ########################################
        # Initialize and use HermesAcronymDetector
        ########################################

        # Path to trained model json file with dspy
        trained_promt = pathlib.Path("data/optimized/HermesAcronymDetector-saved.json")
        
        # Verify if the model should be trained
        should_train = do_train or "HermesAcronymDetector" in (config.get('modules_to_train') or [])

        if should_train:
            # Train the model
            logger.info("Entrenando y usando HermesAcronymDetector...")
            detector = HermesAcronymDetector(
                do_train=True,
                data_path=args.data_path,
                trained_promt=trained_promt,
                logger=logger
            )
            # After training, verify if the model was saved correctly
            if not trained_promt.exists():
                logger.error(f"El modelo entrenado no se guardó correctamente en {trained_promt}.")
                raise FileNotFoundError(f"El modelo entrenado no se encuentra en {trained_promt}.")
        else:
            # Use the pre-trained model
            if trained_promt.exists():
                logger.info(f"Cargando AcronymDetectorModule preentrenado desde {trained_promt}...")
                time.sleep(5)
                detector = HermesAcronymDetector(
                    do_train=False,
                    data_path=args.data_path,
                    trained_promt=trained_promt,
                    logger=logger
                )
            else:
                # If the model don´t have trained_promt, raise an error
                logger.error(f"No se encontró el modelo entrenado en {trained_promt}. Considera entrenarlo primero.")
                raise FileNotFoundError(f"El modelo entrenado no existe en {trained_promt}. Entrena el modelo antes de usarlo.")
        
        # Configure the module to use the Retry transformation with a maximum of 2 backtracks
        detector.module = assert_transform_module(
            detector.module.map_named_predictors(dspy.Retry),
            functools.partial(backtrack_handler, max_backtracks=2) 
        )
        try:
            df_out = process_dataframe(
                path=args.data_path,
                config=config,
                acronym_detector=detector.module,
                context_window=args.context_window,
                max_windows=args.max_windows,
                window_overlap=args.window_overlap
            )
        except Exception as e:
            logger.error(f"Ocurrió un error al procesar el DataFrame: {str(e)}")
            raise e

    # @TODO: Update the code of the AcronymExpanderModule
    if args.action in ["expand", "both"]:
        ########################################
        # Initialize and use HermesAcronymExpander
        ########################################
        if do_train or "HermesAcronymExpander" in config.get('modules_to_train', []):
            logger.info("Inicializando y usando HermesAcronymExpander...")
            expander = HermesAcronymExpander(
                do_train=do_train,
                data_path=args.data_path,
                logger=logger
            )
        else:
            logger.info("Cargando AcronymExpanderModule preentrenado...")
            expander = HermesAcronymExpander(do_train=False, logger=logger)
        
        # Asumiendo que los acrónimos detectados están en 'Acronyms Detected(LLM)'
        for idx, row in df.iterrows():
            detected_acronyms = row.get('Acronyms Detected(LLM)', '')
            expansions = []
            if detected_acronyms and detected_acronyms != '/':
                for acronym in detected_acronyms.split(','):
                    prediction = expander.module.forward(row['text'], acronym.strip())
                    expansions.append(prediction.EXPANSION)
                df.at[idx, 'Acronyms Expanded'] = ', '.join(expansions)
            else:
                df.at[idx, 'Acronyms Expanded'] = '/'

    # Save df in a new Excel file with the same name as the input file plus '_out'
    path = pathlib.Path(args.data_path)
    path_out = path.with_stem(path.stem + '_out').with_suffix('.xlsx')
    df_out.to_excel(path_out, index=False)
    logger.info(f"DataFrame procesado y guardado en {path_out}")
    
    
    #my_acronym_expander = AcronymExpanderModule()
    #texto="Ejemplo de texto para pib de la sociedad española de la federación de empresarios agrarios"
    #acronimo="pib"
    # Uso del módulo
    #my_acronym_expander = AcronymExpanderModule()
    #result = my_acronym_expander(texto,acronimo)
    #print("Resultado:", result)
    # Ahora se puede usar el expansor para expandir acrónimos
    #expander.module(texto="Quiero participar en una ONG porque quiero ser caritativa", acronimo="ONG")